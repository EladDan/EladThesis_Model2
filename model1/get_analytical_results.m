function [ Refl, Abso, Tran ] = get_analytical_results( Params )
% Anaylical solution:
% 1. build first row of the (I-P)^-1 mat
% 2. build eta matrix
% multiply them
N = Params.N;
r = Params.r_red;
a = Params.a_red;
t = (1-r)*(1-a);


p = t;
q = r;

term_1 = sqrt(-4*p^2 + (1 + p^2 - q^2)^2);


% build first row of the (I-P)^-1 mat
z = (-2^-N*q*(1/p*(1 + p^2 - q^2 -term_1))^(-1+N)+...
    (2^(1-N)*q*(1/p*(1 + p^2 - q^2 - term_1))^(-1+N))/...
    (term_1) -...
    (2^-N*q*(1/p*(1 + p^2 - q^2 -term_1))^(-1+N))/...
    (term_1) + ...
    (2^-N*p^2*q*(1/p*(1 + p^2 - q^2 - term_1))^(-1+N))/...
    (term_1) -...
    (2^-N * q^3 *(1/p * (1 + p^2 - q^2 - term_1))^(-1+N))/...
    (term_1) -...
    2^-N * q *(1/p*(1 + p^2 - q^2 + term_1))^(-1+N) -...
    (2^(1 - N)*q*(1/p * (1 + p^2 - q^2 + term_1))^(-1+N))/...
    (sqrt(-4 * p^2 + (1 + p^2 - q^2)^2)) + ...
    (2^-N*q*(1/p*(1 + p^2 - q^2 + term_1))^(-1+N))/...
    (term_1) -...
    (2^-N*p^2*q*(1/p*(1 + p^2 - q^2 + term_1))^(-1+N))/...
    (term_1) +...
    (2^-N*q^3*(1/p*(1 + p^2 - q^2 + term_1))^(-1+N))/...
    (term_1))/...
    (-2^-N*(1/p*(1 + p^2 - q^2 - term_1))^(-1 +N) +...
    (2^-N*(1/p*(1 + p^2 - q^2 - term_1))^(-1 +N))/...
    (term_1) -...
    (2^-N*p^2*(1/p*(1 + p^2 - q^2 - term_1))^(-1 +N))/...
    (term_1) -...
    (2^(1 - N)* q^2 *(1/p*(1 + p^2 - q^2 - term_1))^(-1 + N))/...
    (term_1) +...
    (2^-N*q^2*(1/p*(1 + p^2 - q^2 - term_1))^(-1 +N))/...
    (term_1) -...
    2^-N*(1/p*(1 + p^2 - q^2 + term_1))^(-1+N) -...
    (2^-N*(1/p*(1 + p^2 - q^2 + term_1))^(-1+N))/...
    (term_1) +...
    (2^-N * p^2 * (1/p * (1 + p^2 - q^2 + term_1))^(-1+N))/...
    (term_1) +...
    (2^(1 - N) * q^2 * (1/p * (1 + p^2 - q^2 + term_1))^(-1+N))/...
    (term_1) -...
    (2^-N * q^2 * (1/p * (1 + p^2 - q^2 + term_1))^(-1+N))/...
    (term_1));

idx = 1;
x(idx) = 1; % start condition (x(0)=1)
for j = 1:N-1
    idx = idx + 1;
    % f1(j)
    x(idx) = 1/term_1*...
    2^(-1 - j)*((1/p*(1 + p^2 - q^2 - sqrt(-4*p^2 +(1 + p^2 - q^2)^2)))^j -...
    p^2*(1/p*(1 + p^2 - q^2 - term_1))^j +...
    q^2*(1/p*(1 + p^2 - q^2 -term_1))^j +...
    term_1...
    *(1/p*(1 + p^2 - q^2 - sqrt(-4*p^2 +(1 + p^2 - q^2)^2)))^j -...
    (1/p*(1 + p^2 - q^2 + term_1))^j +...
    p^2*(1/p*(1 + p^2 - q^2 + term_1))^j -...
    q^2*(1/p*(1 + p^2 - q^2 + term_1))^j +...
    term_1*...
    (1/p*(1 + p^2 - q^2 + term_1))^j -...
    2*q*(1/p*(1 + p^2 - q^2 - term_1))^j* z +...
    2*q*(1/p*(1 + p^2 - q^2 + term_1))^j* z);
end

for j = 1:N-1
    idx = idx + 1;
    % f2(j)
    x(idx) = 1/term_1 *  2^(-1 - j) *...
    (2*q*(1/p*(1 + p^2 - q^2 - term_1))^j -...
    2*q*(1/p*(1 + p^2 - q^2 + term_1))^j -...
    (1/p*(1 + p^2 - q^2 - term_1))^j * z +...
    p^2 * (1/p * (1 + p^2 - q^2 - term_1))^j*z -...
    q^2 * (1/p * (1 + p^2 - q^2 - term_1))^j*z +...
    term_1*...
    (1/p*(1 + p^2 - q^2 - term_1))^j*z +...
    (1/p*(1 + p^2 - q^2 + term_1))^j*z -...
    p^2 *(1/p *(1 + p^2 - q^2 + term_1))^j * z +...
    q^2 *(1/p *(1 + p^2 - q^2 + term_1))^j * z +...
    term_1*...
    (1/p *(1 + p^2 - q^2 + term_1))^j * z);
end
% here x = inv(I-Part_trans_mat)[1];


% define probabilities vectors: transient states to absorbing states
% (eta used to be pi_k_Aj)
eta = zeros(2*N-1,N+2);
% probability to exit the left PBR (absorbe in state A0)
eta(1,1) = r;
eta(N+1,1) = t;
for k = 1:2*N-1 % possible states
    for j = 2:N+1 % "middle" absorbing states - prob to absorbed in cell i
        if (k+1 == j || k+1 == N+j)
            eta(k,j) = (1-r)*a;
        end
    end
end
% probability to exit the right PBR (absorbe in state An+2)
eta(N,N+2) = t;


% find the "final" probability to move from state 1 to state Aj (our solution)
SS_k_A0_1 = x * eta(:,1);

SS_k_Alast_1 = x * eta(:,N+2);

% take the first row (k=1, initial beam) from the steady-state mat (pi)
Refl = SS_k_A0_1;
Tran = SS_k_Alast_1;
Abso = 1-Refl-Tran;



end

